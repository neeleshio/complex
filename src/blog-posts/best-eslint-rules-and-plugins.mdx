# The Best ESlint Rules & Plugins For React Projects

> ESLint is a popular open-source JavaScript linting utility. It analyzes your code for potential errors, and enforces coding standards while improving code quality. It can also help you as a developer to identify and fix common mistakes, use best practices, and maintain consistency across your codebase.

![eslint](/eslint.png)

## How to use ESLint?

### Install it:

```shell
npm install eslint --save-dev
```

### Initialize it:

```shell
npx eslint --init
```

This command prompts you to multiple options, choose the following options:

![eslint-init](/eslint-init.png)

### Configure it:

The moment you’re done with the installation and initialization you’ll have a .eslintrc.json file in your directory. In it, you’ll see some rules configured like this:

```json
{
    "rules": {
        "semi": ["error", "always"],
        "quotes": ["error", "double"]
    }
}
```

### Use it:

Add it to package.json file.

```json
"scripts": {
  ...
  "lint": "eslint .",
  "lint:fix": "eslint --fix --ext .js,.jsx ."
  ...
}
```

```shell
npm run lint
```

## Official React Plugin

An obvious pick for React projects, but eslint-plugin-react along with their plugin:react/recommended rule set is a must. This will give you some sensible rules such as requiring a key to be specified in JSX arrays.

```shell
npm install eslint-plugin-react --save-dev
```

```json
 "extends": [
    "eslint:recommended",
    "plugin:react/recommended"
  ]
```

eslint-config-airbnb is another good (if a bit loose) base rule set on top of eslint-plugin-react to start from.

## List of some useful eslint rules.

&emsp; **1. react/no-array-index-key**

-   Warn if an element uses an Array index in its key.

&emsp; **2. react/jsx-sort-props**

-   Some developers prefer to sort props names alphabetically to be able to find necessary props easier at the later time. Others feel that it adds complexity and becomes burden to maintain.

&emsp; **3. react/button-has-type**

-   The default value of type attribute for button HTML element is "submit" which is often not the desired behavior and may lead to unexpected page reloads. This rules enforces an explicit type attribute for all the button elements and checks that its value is valid per spec (i.e., is one of "button", "submit", and "reset").

&emsp; **4. react/destructuring-assignment**

-   Enforce consistent usage of destructuring assignment of props, state, and context

&emsp; **5. react/forbid-component-props**

-   By default this rule prevents passing of props that add lots of complexity (className, style) to Components. This rule only applies to Components (e.g. <span className="tag">< Foo /></span>) and not DOM nodes (e.g. <span className="tag">< div /></span>). The list of forbidden props can be customized with the forbid option.

&emsp; **6. react/function-component-definition**

-   This rule is aimed to enforce consistent function types for function components. By default it prefers function declarations for named components and function expressions for unnamed components.

&emsp; **7. react/prefer-stateless-function**

-   Stateless functional components are simpler than class based components and will benefit from future React performance optimizations specific to these components.

&emsp; **8. react/jsx-pascal-case**

-   Enforces coding style that user-defined JSX components are defined and referenced in PascalCase.

&emsp; **9. react/no-children-prop**

-   Disallow passing of children as props. Children should always be actual children, not passed in as a prop.

&emsp; **10. react/no-danger**

-   Dangerous properties in React are those whose behavior is known to be a common source of application vulnerabilities. The properties names clearly indicate they are dangerous and should be avoided unless great care is taken.

&emsp; **11. react/no-unstable-nested-components**

-   Creating components inside components will cause React to throw away the state of those nested components on each re-render of their parent.

&emsp; **12. react/jsx-fragments**

-   In JSX, a React fragment is created either with <span className="tag">< React.Fragmen >...< /React.Fragment > </span>, or, using the shorthand syntax, <span className="tag"> < >...< / ></span>.

&emsp; **13. react/jsx-no-leaked-render**

-   Using the && operator to render some element conditionally in JSX can cause unexpected values being rendered, or even crashing the rendering.

&emsp; **14. react/jsx-max-depth**

-   This option validates a specific depth for JSX. as soon as your components start reaching too far to the right, you know they're getting too big.

&emsp; **15. react/jsx-key**

-   Warn if an element that likely requires a key prop along with checkFragmentShorthand, checkKeyMustBeforeSpread, warnOnDuplicates.

&emsp; **16. react/jsx-no-useless-fragment**

-   A fragment is redundant if it contains only one child, or if it is the child of a html element, and is not a keyed fragment.

&emsp; **17. react/self-closing-comp**

-   Components without children can be self-closed to avoid unnecessary extra closing tag.

&emsp; **18. react/jsx-one-expression-per-line**

-   This option limits every line in JSX to one expression each.

<br />

**Rules usage:**

```json
{
    "rules": {
        "react/no-array-index-key": "error",
        "react/jsx-sort-props": "warn",
        "react/button-has-type": "error",
        "react/destructuring-assignment": [
            "error",
            "always",
            { "destructureInSignature": "always" }
        ],
        "react/forbid-component-props": ["warn", { "forbid": ["className", "style"] }],
        "react/function-component-definition": ["warn", { "namedComponents": "arrow-function" }],
        "react/prefer-stateless-function": "error",
        "react/jsx-pascal-case": "error",
        "react/no-children-prop": "error",
        "react/no-danger": "error",
        "react/no-unstable-nested-components": ["error", { "allowAsProps": true }],
        "react/jsx-fragments": "error",
        "react/jsx-no-leaked-render": ["error", { "validStrategies": ["ternary"] }],
        "react/jsx-max-depth": ["error", { "max": 5 }],
        "react/jsx-key": [
            "error",
            {
                "checkFragmentShorthand": true,
                "checkKeyMustBeforeSpread": true,
                "warnOnDuplicates": true
            }
        ],
        "react/jsx-no-useless-fragment": "warn",
        "react/self-closing-comp": "warn",
        "react/jsx-one-expression-per-line": "off"
    }
}
```

## Some useful eslint plugins

### 1. eslint-plugin-jsx-a11y:

-   jsx-a11y is all about ensuring your DOM elements are accessible. This plugin will prompt you to include the correct ARIA attributes such as labels and roles, in addition to things like alt text.
-   Static AST checker for accessibility rules on JSX elements.
-   This plugin does a static evaluation of the JSX to spot accessibility issues in React apps.

```shell
npm install eslint-plugin-jsx-a11y --save-dev
```

Add jsx-a11y to the plugins section of your .eslintrc configuration file. You can omit the eslint-plugin- prefix:

```shell
{
  "plugins": ["jsx-a11y"]
}
```

Enable all the recommended or strict rules at once. Add plugin:jsx-a11y/recommended or plugin:jsx-a11y/strict in extends:

```shell
{
  "extends": ["plugin:jsx-a11y/recommended"]
}
```

### 2. React Refresh:

-   Requires that .tsx/.jsx files only export components. Why? Because this optimises your app for fash refresh to get a smoother development experience. If you're using Vite, you'll be utilising fash refresh under the hood and will want to enable this rule.
-   Validate that your components can safely be updated with fast refresh

```shell
npm i -D eslint-plugin-react-refresh
```

```shell
{
  "plugins": ["react-refresh"],
  "rules": {
    "react-refresh/only-export-components": "warn"
  }
}
```

### 3. Rules of Hooks:

-   react-hooks with the plugin:react-hooks/recommended rule set will save you more than a few headaches. Importantly, you can't call hooks conditionally, and will be warned if you state dependencies aren't exhaustive.

```shell
npm install eslint-plugin-react-hooks --save-dev
```

```shell
{
  "extends": ["plugin:react-hooks/recommended"]
}
```

## Prettier

Prettier is an opinionated code formatter for JavaScript and other popular languages. Prettier enforces a consistent format by parsing code and reprinting it with its own rules that take the maximum line length into account, wrapping code when necessary.

-   While ESLint takes care of your code style, Prettier takes care of your code formatting.
-   Prettier enforces a consistent code style across your entire codebase.

## Integrating Prettier with ESLint

-   Linters(ESLint) usually contain not only code quality rules, but also stylistic rules.
-   Most stylistic rules are unnecessary when using Prettier, but worse – they might conflict with Prettier! Use Prettier for code formatting concerns, and linters for code-quality concerns.

-   Luckily it’s easy to turn off rules that conflict or are unnecessary with Prettier, by using these pre-made configs:

<br />
### 1. Let's install the necessary prettier packages

```shell
npm install -D prettier eslint-plugin-prettier eslint-config-prettier
```

**eslint-plugin-prettier:**

-   Runs Prettier as an ESLint rule and reports differences as individual ESLint issues.
-   Plugins usually contain implementations for additional rules that ESLint will check for. This plugin uses Prettier under the hood and will raise ESLint errors when your code differs from Prettier's expected output.

**eslint-config-prettier:**

-   Turns off all rules that are unnecessary or might conflict with Prettier.
-   This config turns off formatting-related rules that might conflict with Prettier, allowing you to use Prettier with other ESLint configs like eslint-config-airbnb.

<br />
### 2. Add prettier to your ESLint configuration

```shell
# .eslintrc.json

 "plugins": ["prettier"]
 "extends": ["plugin:prettier/recommended"],
```

<br />
### 3. Config prettier

Now for our Prettier configurations, we need to create a file called .prettierrc, then add your Prettier rules in that file.

```shell
# .prettierrc

{
    "semi": true,
    "tabWidth": 4,
    "printWidth": 100,
    "singleQuote": true,
    "trailingComma": "none",
    "bracketSameLine": true
}
```

### 4. Run prettier

<br />

_Use this command if you just need to check the issues._

```shell
npx prettier . --check
```

_Use this command if you want to fix the issues automatically._

```shell
npx prettier . --write
```

### 5. For VS Code

For VS Code, you can install ESLint & Prettier extensions to take more advantage.

-   Once you have these two extensions, you can add these settings in your .vscode/settings.json or you can add them in your global settings.
-   This will make prettier as our default formatter.
-   And it will automatically format our file whenever we save a file.

```json
 "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  }
```

## Conclusion

Using the rules above will improve your code quality, consistency, and reduce the risk of bugs. However, every project is different and every team has their own styles and conventions, so I'd suggest tweaking rules to your needs. With that said, it's better to start with a stricter rule set then loosen it to reduce any false positives or noise. This encourages you to think critically about the code you write, and make the conscious decision to ignore rules if you need rather than be ignorant to certain anti-patterns.
